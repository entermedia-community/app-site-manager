package org.entermedia.sitemanager;

import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.entermediadb.asset.MediaArchive;
import org.openedit.Data;
import org.openedit.OpenEditException;
import org.openedit.money.Money;
import org.openedit.page.manage.PageManager;
import org.openedit.users.User;
import org.openedit.util.XmlUtil;

import com.stripe.Stripe;
import com.stripe.model.BalanceTransaction;
import com.stripe.model.Charge;
import com.stripe.model.Customer;
import com.stripe.model.Fee;


public class StripePaymentProcessor 
{

	private static final Log log = LogFactory.getLog(StripePaymentProcessor.class);
	protected PageManager fieldPageManager;
	protected XmlUtil fieldXmlUtil;


	

	

	


	protected void process(MediaArchive inArchive, User inUser, Data payment,  String inToken) 
	{
		log.info("processing order with Stripe");
		
		Map<String, Object> chargeParams = new HashMap<String, Object>();
		Money totalprice = new Money(payment.get("totalprice"));
		//stripe connect: use access_token generated by oauth in place of 
		//secretkey; also define application fee (application_fee parameter)
		boolean forcetestmode = Boolean.parseBoolean(payment.get("forcetestmode"));
		boolean productionmode = inArchive.isCatalogSettingTrue("productionmode");
		if(productionmode && !forcetestmode){
			Stripe.apiKey  = inArchive.getCatalogSettingValue("stripe_access_token");
		} else{
			Stripe.apiKey  = inArchive.getCatalogSettingValue("stripe_test_access_token");
		}
		String amountstring = totalprice.toShortString().replace(".", "").replace("$", "").replace(",", "");
		chargeParams.put("amount", amountstring);
		String currency = inArchive.getCatalogSettingValue("currency");
		if(currency == null){
			currency = "usd";
		}
		chargeParams.put("currency", currency);
		String descriptor = inArchive.getCatalogSettingValue("statement_descriptor");
		if(descriptor != null){
			chargeParams.put("statement_descriptor", descriptor);
		}	
		Map<String,String> initialMetadata = new HashMap<String,String>();
		populateMetadata(payment,inUser,initialMetadata);
		chargeParams.put("description",payment.getId());
		chargeParams.put("metadata", initialMetadata);
		try
		{
			
			
			
			String customerid = inUser.get("stripeid");
			if(customerid == null){
				Map<String, Object> customerParams = new HashMap<String, Object>();
				customerParams.put("email", inUser.getEmail());
				customerParams.put("source", inToken);
				
				Customer customer = Customer.create(customerParams);
				customerid = customer.getId();
				inUser.setValue("stripeid", customer.getId());
				inArchive.getUserManager().saveUser(inUser);
			}				
			chargeParams.put("customer", customerid); // obtained via js
//	https://stripe.com/docs/saving-cards
			
			
			Charge c = Charge.create(chargeParams);
			String balancetransaction = c.getBalanceTransaction();
			BalanceTransaction balance = BalanceTransaction.retrieve(balancetransaction);
			long fee = balance.getFee();
			float moneyval = (float)fee / 100;
			payment.setProperty("fee", String.valueOf(moneyval));
			List<Fee> details = balance.getFeeDetails();
			for (Iterator<Fee> iterator = details.iterator(); iterator.hasNext();)
			{
				Fee fee2 = iterator.next();
				float feeval = (float)fee2.getAmount() / 100;
				if("stripe_fee".equals(fee2.getType())){
					payment.setProperty("stripefee", String.valueOf(feeval));
				}
				if("application_fee".equals(fee2.getType())){
					payment.setProperty("profitshare", String.valueOf(feeval));
				}
			}
			payment.setProperty("balancetransaction", balancetransaction);
			float net = (float) balance.getNet() / 100;
			payment.setProperty("net", String.valueOf(net));
			payment.setProperty("stripechargeid", c.getId());
		}

		catch (Exception e)
		{
		throw new OpenEditException(e);
		}

	}
	
	
	

//	@Override
//	public void refundOrder(WebPageRequest inContext, Store inStore, Order inOrder, Refund inRefund) throws StoreException
//	{
//		if (!requiresValidation(inStore, inOrder)) {
//			return;
//		}
//		log.info("refunding order with Stripe");
//		if(inOrder.get("stripetoken") == null || inOrder.get("stripechargeid")==null){
//			log.error("cannot find stripetoken, aborting");
//			return;
//		}
//		String chargeId = inOrder.get("stripechargeid");
//		//set application key
//		boolean forcetestmode = inOrder.getBoolean("forcetestmode");
//		Data setting = null;
//		if(inStore.isProductionMode()){
//			 setting = getSearcherManager().getData(inStore.getCatalogId(), "catalogsettings", "stripe_access_token");
//		} else{
//			 setting = getSearcherManager().getData(inStore.getCatalogId(), "catalogsettings", "stripe_test_access_token");
//		}
//		if (setting!=null && setting.get("value")!=null){
//			Stripe.apiKey = setting.get("value");
//		} else {
//			//check if an administrator has ordered test mode transaction
//			if(inStore.isProductionMode() && !forcetestmode){
//				Stripe.apiKey = inStore.get("secretkey");//livesecretkey or secretkey
//			} else{
//				Stripe.apiKey = inStore.get("testsecretkey");
//			}
//		}
//		try{
//			//load the charge
//			Charge c = Charge.retrieve(chargeId);
//			if (c.getRefunded()){//this is true if fully refunded
//				inRefund.setSuccess(false);
//				inRefund.setMessage("Order has already been refunded");
//
//				inRefund.setDate(new Date());
//			} else {
//				Integer total = c.getAmount();
//				Integer totalrefunded = c.getAmountRefunded();
//				Integer refundamount = Integer.parseInt(inRefund.getTotalAmount().toShortString().replace(".","").replace(",",""));
//				if(refundamount > total){
//					refundamount = total;
//				}
//				Map<String, Object> params = new HashMap<String, Object>();
//				params.put("amount", String.valueOf(refundamount));
//				com.stripe.model.Refund refund = c.getRefunds().create(params);
//				inRefund.setSuccess(true);
//				inRefund.setProperty("refundedby" , inContext.getUserName());
//
//				inRefund.setAuthorizationCode(refund.getId());
//				inRefund.setTransactionId(refund.getBalanceTransaction());
//				inRefund.setDate(new Date());
//				//calculate whether application fees should be handled
//				//need to fix this logic:
//				//handle application fees work only when we have one item on the cart 
//				//and when the store is not setup to handle profit shares
//				handleApplicationFees(chargeId,inRefund);
//				
//				//OLD!!!
////				Charge refundedCharge = c.refund();//refunds the full amount
////				if (refundedCharge.getRefunded()){
////					ChargeRefundCollection refunds = refundedCharge.getRefunds();
////					com.stripe.model.Refund refund = refunds.getData().get(0);
////					inRefund.setSuccess(true);
////					inRefund.setAuthorizationCode(refund.getId());
////					inRefund.setTransactionId(refund.getBalanceTransaction());
////					inRefund.setDate(new Date());
////					//client was refunded at this point, but
////					//partners have not been
////					//handle this at the end
////					handleApplicationFees(chargeId,inRefund);
////					
////				} else {
////					inRefund.setSuccess(false);
////					inRefund.setMessage("Order could not be refunded");
////					inRefund.setDate(new Date());
////				}
//			}
//		}catch (Exception e){
//			inRefund.setSuccess(false);
//			inRefund.setMessage("An error occurred while processing your transaction.");
//			e.printStackTrace();
//			throw new StoreException(e);
//		}
//	}
	
//	protected void handleApplicationFees(String inChargeId, Refund inRefund){
//		try{
//			Map<String, Object> params = new HashMap<String, Object>();
//			params.put("charge",inChargeId);
//			ApplicationFeeCollection collection = ApplicationFee.all(params);
//			List<ApplicationFee> fees  = collection.getData();
//			if (fees.size() > 0){
//				//refund all fees
//				StringBuilder buf = new StringBuilder();
//				for (ApplicationFee fee:fees){
//					//here we will probably have to refund partial amounts
//					if (!fee.getRefunded()){
//						ApplicationFee refundedFee = fee.refund();
//						if (!refundedFee.getRefunded()){
//							buf.append("ID:").append(fee.getId()).append(" ");
//						}
//					}
//				}
//				if (buf.toString().isEmpty()){
//					inRefund.setMessage("All application fees were refunded");
//				} else {
//					inRefund.setMessage("Unable to refund all application fees, "+buf.toString().trim());
//				}
//			} else {
//				inRefund.setMessage("No application fees were found on this order");
//			}
//		}catch (Exception e){
//			log.error(e.getMessage(), e);
//		}
//	}
	
	protected void populateMetadata(Data inOrder, User inUser,  Map<String,String> inMetadata){
		inMetadata.put("firstname", inUser.getFirstName());
		inMetadata.put("lastname", inUser.getLastName());
		inMetadata.put("email", inUser.getEmail());
		
//		Address billing = inOrder.getCustomer().getBillingAddress();
//		inMetadata.put("billingaddress",billing.toString());
//		Address shipping = inOrder.getCustomer().getShippingAddress();
//		inMetadata.put("shippingaddress",shipping.toString());
//		Iterator<?> itr = inOrder.getItems().iterator();
//		for(int i=1; itr.hasNext(); i++){
//			CartItem item = (CartItem) itr.next();
//			String sku = item.getSku();
//			String name = item.getName();
//			Money price = item.getYourPrice();
//			StringBuilder buf = new StringBuilder();
//			buf.append(sku).append(": ");
//			if (Coupon.isCoupon(item)){
//				buf.append("Coupon - ");
//			}
//			buf.append(name).append(" ").append(price.toShortString());
//			inMetadata.put("cartitem-"+i, buf.toString());
//		}
	}
	
	
	
	
//	public Money calculateFee(MediaArchive inStore, Data inOrder){
//		Money totalFee = new Money("0");
//		@SuppressWarnings("unchecked")
//		Iterator<CartItem> itr = inOrder.getItems().iterator();
//		while(itr.hasNext()){
//			CartItem item = itr.next();
//			Product product = item.getProduct();
//			if (product.isCoupon()){
//				continue;
//			}
//			String fee = product.get("partnershipfee");
//			String type = product.get("partnershipfeetype");
//			if (fee!=null && type!=null){
//				if (type.equals("flatrate")){
//					Money money = new Money(fee);
//					if (money.isNegative() || money.isZero()){
//						continue;
//					}
//					totalFee = totalFee.add(money);
//				} else if (type.equals("percentage")){
//					Money itemprice = item.getTotalPrice();
//					double rate = Double.parseDouble(fee);
//					if (rate < 0.0d || rate > 1.0d){
//						continue;
//					}
//					Money money = itemprice.multiply(new Fraction(rate));
//					totalFee = totalFee.add(money);
//				}
//			}
//		}
//		if (totalFee.isZero() && inStore.get("fee_structure")!=null){
//			String fee_structure = inStore.get("fee_structure");
//			double rate = Double.parseDouble(fee_structure);
//			totalFee = new Money(rate);
//			if (rate < 1.0d){
//				totalFee = inOrder.getSubTotal().multiply(new Fraction(rate));
//			}
//		}
//		String fee = inOrder.get("fee");//transaction fee
//		double totalFeed = totalFee.doubleValue();
//		if (fee!=null && fee.isEmpty()==false){
//			Money transfee = new Money(fee);
//			if (transfee.isZero() == false && totalFee.isZero() == false){
//				Money charged = inOrder.getSubTotal(); //this is what we sent to stripe
//				double chargedd = charged.doubleValue();
//				double ratio = totalFeed/chargedd;
//				
//				
//				
//				transfee = transfee.multiply(new Fraction(ratio));//divide by 2  Not correct - need to divide by the ratio of the share
//				totalFee = totalFee.subtract(transfee);
//			}
//		}
//		inOrder.setProperty("profitshare", Double.toString(totalFee.doubleValue()));
//		return totalFee;
//	}
//	
	
	
}
